package main

import (
	"encoding/json"
	"fmt"
	"go/build"
	"io/fs"
	"math/rand"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"time"

	"github.com/matloob/index"
	"github.com/matloob/index/internal/diff"
	"golang.org/x/mod/module"
)

func modVers(modcache string, path string) (module.Version, string, bool) {
	relToCache := path[len(modcache):]
	at := strings.IndexRune(relToCache, '@')
	if at == -1 {
		return module.Version{}, "", false
	}
	modulePath := filepath.ToSlash(relToCache[:at])
	rest := relToCache[at+1:]
	sep := strings.IndexRune(rest, filepath.Separator)
	version, pathInModule := rest, ""
	if sep != -1 {
		version = rest[:sep]
		pathInModule = filepath.ToSlash(rest[sep+1:])
	}
	return module.Version{modulePath, version}, pathInModule, true
}

var globalAllTags = []string{
	"1.6",
	"386",
	"acceptance",
	"acls",
	"actions",
	"addressscopes",
	"admin",
	"agents",
	"aggregates",
	"aix",
	"allocations",
	"alpha",
	"amd64",
	"amd64p32",
	"android",
	"appengine",
	"appenginevm",
	"arduino",
	"arduino_mega2560",
	"arduino_nano",
	"arduino_nano33",
	"arm",
	"arm64",
	"arm64be",
	"armbe",
	"atmega1284p",
	"atsamd21",
	"atsamd51",
	"atsame5x",
	"autocert",
	"autogen",
	"availabilityzones",
	"avr",
	"awsinclude",
	"bad",
	"baremetal",
	"bench",
	"blockstorage",
	"bootfromvolume",
	"bounds",
	"capsules",
	"cblas",
	"cgo",
	"circuitplay_express",
	"claims",
	"cluster_proxy",
	"clustering",
	"cmp_debug",
	"codegen",
	"complex_tests",
	"compute",
	"containerinfra",
	"containers",
	"cov",
	"darwin",
	"db",
	"dbexamples",
	"defsecrules",
	"determine",
	"dev",
	"digispark",
	"disable_events",
	"disableunsafe",
	"dns",
	"dragonfly",
	"easyjson_nounsafe",
	"ebpf",
	"events",
	"example",
	"exclude_disk_quota",
	"exclude_graphdriver_aufs",
	"exclude_graphdriver_btrfs",
	"exclude_graphdriver_devicemapper",
	"exclude_graphdriver_fuseoverlayfs",
	"exclude_graphdriver_overlay",
	"exclude_graphdriver_overlay2",
	"exclude_graphdriver_zfs",
	"extensions",
	"fe310",
	"feather_m4",
	"feather_m4_can",
	"feather_nrf52840",
	"flavors",
	"floatingips",
	"fortran",
	"freebsd",
	"functional",
	"fuzz",
	"fwaas",
	"gc",
	"gccgo",
	"generate",
	"go.1.16",
	"go1.1",
	"go1.10",
	"go1.11",
	"go1.12",
	"go1.13",
	"go1.14",
	"go1.15",
	"go1.16",
	"go1.17",
	"go1.18",
	"go1.2",
	"go1.3",
	"go1.4",
	"go1.5",
	"go1.6",
	"go1.7",
	"go1.8",
	"go1.9",
	"go18",
	"godirwalk_debug",
	"gofuzz",
	"gofuzzbeta",
	"golint",
	"good",
	"grpcgoid",
	"have_btrfs",
	"have_chainfs",
	"here",
	"hypervisors",
	"i386",
	"icu",
	"identity",
	"ignore",
	"ignore_autogenerated",
	"illumos",
	"imageimport",
	"images",
	"imageservice",
	"include_gcs",
	"include_oss",
	"integration",
	"ios",
	"journald",
	"journald_compat",
	"js",
	"jsoniter",
	"jsoniter_sloppy",
	"k210",
	"keymanager",
	"keypairs",
	"l7policies",
	"layer3",
	"lbaas",
	"lbaas_v2",
	"libdm_dlsym_deferred_remove",
	"libdm_no_deferred_remove",
	"libipmctl",
	"libpfm",
	"limits",
	"linux",
	"listeners",
	"loadbalancer",
	"loadbalancers",
	"m68k",
	"macnative",
	"member",
	"messages",
	"messaging",
	"metal",
	"microbit",
	"microbit_v2",
	"mimxrt1062",
	"mips",
	"mips64",
	"mips64le",
	"mips64p32",
	"mips64p32le",
	"mips64x",
	"mipsle",
	"modhack",
	"monitors",
	"nacl",
	"need",
	"netbsd",
	"networking",
	"networkipavailabilities",
	"nios2",
	"no",
	"no_btrfs",
	"no_cri",
	"no_lcow",
	"noasm",
	"nodes",
	"none",
	"nope",
	"noresumabledigest",
	"notravis",
	"nrf51",
	"nrf52",
	"nrf52833",
	"nrf52840",
	"ok",
	"one",
	"openbsd",
	"orders",
	"p1am_100",
	"panictest",
	"perftest",
	"plan9",
	"policies",
	"policytypes",
	"pool",
	"pools",
	"ports",
	"ppc",
	"ppc64",
	"ppc64le",
	"ppc64x",
	"profiletypes",
	"protolegacy",
	"protoreflect",
	"provider",
	"purego",
	"pybadge",
	"pygamer",
	"pyportal",
	"qtpy",
	"queues",
	"quotasets",
	"race",
	"recordsets",
	"remoteconsoles",
	"rescueunrescue",
	"riscv",
	"riscv64",
	"roles",
	"router",
	"s390",
	"s390x",
	"s3crypto_integ",
	"safe",
	"seccomp",
	"secgroups",
	"secrets",
	"security",
	"servergroups",
	"servers",
	"services",
	"sh",
	"shbe",
	"skip",
	"solaris",
	"something",
	"sparc",
	"sparc64",
	"static_build",
	"stm32f103xx",
	"stm32f405",
	"stm32f407",
	"subnetpools",
	"tag",
	"tags",
	"tasks",
	"test",
	"testcgo",
	"three",
	"tinygo",
	"to",
	"tomita",
	"tools",
	"trunks",
	"two",
	"typeparams",
	"usage",
	"v2v3",
	"versions",
	"vip",
	"vlantransparent",
	"volumeattach",
	"vpnaas",
	"wasm",
	"we",
	"weak_dependency",
	"webhooks",
	"which",
	"windows",
	"wioterminal",
	"worse",
	"x86",
	"xtensa",
	"zones",
	"zos",
}

func main() {
	modcache := "/users/matloob/go/pkg/mod/"
	modcachecache := filepath.Join(modcache, "cache")
	dir := "/users/matloob/go/pkg/mod/"

	enc := json.NewEncoder(os.Stdout)
	enc.SetIndent("\t\t", "\t")

	var pass, all int

	rand.Seed(time.Now().UnixNano())

	var actualTags []string
	for _, tag := range globalAllTags {
		if rand.Intn(2) != 0 {
			actualTags = append(actualTags, tag)
		}
	}

	fmt.Println("actual tags are")
	fmt.Println(actualTags)

	ctx := build.Default
	ctx.BuildTags = actualTags

	modules := make(map[module.Version]*index.RawModule)

	filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if path == modcachecache {
			return filepath.SkipDir
		}
		if !d.IsDir() {
			return nil
		}
		modVers, _, ok := modVers(modcache, path)
		if !ok {
			return nil
		}
		ind := index.IndexModule(path)
		// roundtrip it
		mm, err := json.MarshalIndent(ind, "", "\t")
		var ind2 index.RawModule
		json.Unmarshal(mm, &ind2)
		_ = ind2
		modules[modVers] = &ind2
		return filepath.SkipDir
	})

	fmt.Println("done indexing")

	filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if path == modcachecache {
			return filepath.SkipDir
		}
		if !d.IsDir() {
			return nil
		}

		v, pkgpath, ok := modVers(modcache, path)
		if !ok {
			return nil
		}

		all++

		got, gotErr := index.Cook(ctx, modules[v].Dirs[pkgpath], 0)
		// got, gotErr := getPackageRC(path)
		want, wantErr := ctx.ImportDir(path, 0)

		if gotErr != nil || wantErr != nil {
			if (gotErr == nil) != (wantErr == nil) || gotErr.Error() != wantErr.Error() {
				fmt.Printf("ERROR(%s): got error %v; want error %v\n", path, gotErr, wantErr)
			}
		}
		if !reflect.DeepEqual(got, want) {
			fmt.Println("ERROR(" + path + ")\n\tgot package")
			enc.Encode(got)
			got, _ := json.MarshalIndent(got, "", "\t")

			fmt.Println("\twant package")
			enc.Encode(want)
			want, _ := json.MarshalIndent(want, "", "\t")
			b, _ := diff.Diff("", got, want)
			os.Stdout.Write(b)
			return nil
		}
		pass++
		return nil
	})
	if pass == all {
		fmt.Print("PASS")
	} else {
		fmt.Print("FAIL")
	}
	fmt.Printf(" %v/%v passing packages\n", pass, all)
}

func getPackageRC(path string) (*build.Package, error) {
	// mode seems to be zero for ModulesEnabled
	return index.Cook(build.Default, index.ImportDirRaw(path), 0)
}
