package main

import (
	"encoding/json"
	"fmt"
	"go/build"
	"io/fs"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	pathpkg "path"
	"path/filepath"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"time"

	"github.com/matloob/index"
	"github.com/matloob/index/internal/diff"
	"golang.org/x/mod/module"
)

func modVers(modcache string, path string) (module.Version, string, bool) {
	relToCache := path[len(modcache):]
	at := strings.IndexRune(relToCache, '@')
	if at == -1 {
		return module.Version{}, "", false
	}
	modulePath := filepath.ToSlash(relToCache[:at])
	rest := relToCache[at+1:]
	sep := strings.IndexRune(rest, filepath.Separator)
	version, pathInModule := rest, ""
	if sep != -1 {
		version = rest[:sep]
		pathInModule = filepath.ToSlash(rest[sep+1:])
	}
	return module.Version{modulePath, version}, pathInModule, true
}

var globalAllTags = []string{
	"1.6",
	"386",
	"acceptance",
	"acls",
	"actions",
	"addressscopes",
	"admin",
	"agents",
	"aggregates",
	"aix",
	"allocations",
	"alpha",
	"amd64",
	"amd64p32",
	"android",
	"appengine",
	"appenginevm",
	"arduino",
	"arduino_mega2560",
	"arduino_nano",
	"arduino_nano33",
	"arm",
	"arm64",
	"arm64be",
	"armbe",
	"atmega1284p",
	"atsamd21",
	"atsamd51",
	"atsame5x",
	"autocert",
	"autogen",
	"availabilityzones",
	"avr",
	"awsinclude",
	"bad",
	"baremetal",
	"bench",
	"blockstorage",
	"bootfromvolume",
	"bounds",
	"capsules",
	"cblas",
	"cgo",
	"circuitplay_express",
	"claims",
	"cluster_proxy",
	"clustering",
	"cmp_debug",
	"codegen",
	"complex_tests",
	"compute",
	"containerinfra",
	"containers",
	"cov",
	"darwin",
	"db",
	"dbexamples",
	"defsecrules",
	"determine",
	"dev",
	"digispark",
	"disable_events",
	"disableunsafe",
	"dns",
	"dragonfly",
	"easyjson_nounsafe",
	"ebpf",
	"events",
	"example",
	"exclude_disk_quota",
	"exclude_graphdriver_aufs",
	"exclude_graphdriver_btrfs",
	"exclude_graphdriver_devicemapper",
	"exclude_graphdriver_fuseoverlayfs",
	"exclude_graphdriver_overlay",
	"exclude_graphdriver_overlay2",
	"exclude_graphdriver_zfs",
	"extensions",
	"fe310",
	"feather_m4",
	"feather_m4_can",
	"feather_nrf52840",
	"flavors",
	"floatingips",
	"fortran",
	"freebsd",
	"functional",
	"fuzz",
	"fwaas",
	"gc",
	"gccgo",
	"generate",
	"go.1.16",
	"go1.1",
	"go1.10",
	"go1.11",
	"go1.12",
	"go1.13",
	"go1.14",
	"go1.15",
	"go1.16",
	"go1.17",
	"go1.18",
	"go1.2",
	"go1.3",
	"go1.4",
	"go1.5",
	"go1.6",
	"go1.7",
	"go1.8",
	"go1.9",
	"go18",
	"godirwalk_debug",
	"gofuzz",
	"gofuzzbeta",
	"golint",
	"good",
	"grpcgoid",
	"have_btrfs",
	"have_chainfs",
	"here",
	"hypervisors",
	"i386",
	"icu",
	"identity",
	"ignore",
	"ignore_autogenerated",
	"illumos",
	"imageimport",
	"images",
	"imageservice",
	"include_gcs",
	"include_oss",
	"integration",
	"ios",
	"journald",
	"journald_compat",
	"js",
	"jsoniter",
	"jsoniter_sloppy",
	"k210",
	"keymanager",
	"keypairs",
	"l7policies",
	"layer3",
	"lbaas",
	"lbaas_v2",
	"libdm_dlsym_deferred_remove",
	"libdm_no_deferred_remove",
	"libipmctl",
	"libpfm",
	"limits",
	"linux",
	"listeners",
	"loadbalancer",
	"loadbalancers",
	"m68k",
	"macnative",
	"member",
	"messages",
	"messaging",
	"metal",
	"microbit",
	"microbit_v2",
	"mimxrt1062",
	"mips",
	"mips64",
	"mips64le",
	"mips64p32",
	"mips64p32le",
	"mips64x",
	"mipsle",
	"modhack",
	"monitors",
	"nacl",
	"need",
	"netbsd",
	"networking",
	"networkipavailabilities",
	"nios2",
	"no",
	"no_btrfs",
	"no_cri",
	"no_lcow",
	"noasm",
	"nodes",
	"none",
	"nope",
	"noresumabledigest",
	"notravis",
	"nrf51",
	"nrf52",
	"nrf52833",
	"nrf52840",
	"ok",
	"one",
	"openbsd",
	"orders",
	"p1am_100",
	"panictest",
	"perftest",
	"plan9",
	"policies",
	"policytypes",
	"pool",
	"pools",
	"ports",
	"ppc",
	"ppc64",
	"ppc64le",
	"ppc64x",
	"profiletypes",
	"protolegacy",
	"protoreflect",
	"provider",
	"purego",
	"pybadge",
	"pygamer",
	"pyportal",
	"qtpy",
	"queues",
	"quotasets",
	"race",
	"recordsets",
	"remoteconsoles",
	"rescueunrescue",
	"riscv",
	"riscv64",
	"roles",
	"router",
	"s390",
	"s390x",
	"s3crypto_integ",
	"safe",
	"seccomp",
	"secgroups",
	"secrets",
	"security",
	"servergroups",
	"servers",
	"services",
	"sh",
	"shbe",
	"skip",
	"solaris",
	"something",
	"sparc",
	"sparc64",
	"static_build",
	"stm32f103xx",
	"stm32f405",
	"stm32f407",
	"subnetpools",
	"tag",
	"tags",
	"tasks",
	"test",
	"testcgo",
	"three",
	"tinygo",
	"to",
	"tomita",
	"tools",
	"trunks",
	"two",
	"typeparams",
	"usage",
	"v2v3",
	"versions",
	"vip",
	"vlantransparent",
	"volumeattach",
	"vpnaas",
	"wasm",
	"we",
	"weak_dependency",
	"webhooks",
	"which",
	"windows",
	"wioterminal",
	"worse",
	"x86",
	"xtensa",
	"zones",
	"zos",
}

func main() {
	modcache := "/users/matloob/go/pkg/mod/"
	modcachecache := filepath.Join(modcache, "cache")
	dir := "/users/matloob/go/pkg/mod/"

	enc := json.NewEncoder(os.Stdout)
	enc.SetIndent("\t\t", "\t")

	tmpDir, err := ioutil.TempDir("", "")
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("tmpdir is", tmpDir)

	modules := make(map[module.Version]*index.ModuleIndex)

	filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if path == modcachecache {
			return filepath.SkipDir
		}
		if !d.IsDir() {
			return nil
		}
		modVers, _, ok := modVers(modcache, path)
		if !ok {
			return nil
		}
		rm, err := index.IndexModule(path)
		if err != nil {
			log.Fatal(err)
		}
		indexfiledir := filepath.Join(tmpDir, modVers.String())
		os.MkdirAll(indexfiledir, 755)
		indexfilepath := filepath.Join(indexfiledir, "go.index")
		fmt.Println("*", indexfilepath)
		err = WriteIndexRawModule(indexfilepath, rm, path)
		if err != nil {
			log.Fatal("ppp", err)
		}

		// open module index
		modules[modVers], err = index.Open(indexfilepath, filepath.Join(path, "go.index"))
		if err != nil {
			log.Fatal(err)
		}
		return filepath.SkipDir
	})
	fmt.Println("done indexing")

	try := func(ctx build.Context) {
		var pass, all int

		filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
			if path == modcachecache {
				return filepath.SkipDir
			}
			if !d.IsDir() {
				return nil
			}

			v, pkgpath, ok := modVers(modcache, path)
			_ = pkgpath
			if !ok {
				return nil
			}

			all++

			got, gotErr := modules[v].ImportPackage(ctx, path, 0)
			// got, gotErr := getPackageRC(path)
			want, wantErr := ctx.ImportDir(path, 0)

			if gotErr != nil || wantErr != nil {
				if (gotErr == nil) != (wantErr == nil) || gotErr.Error() != wantErr.Error() {
					fmt.Printf("ERROR(%s): got error %v; want error %v\n", path, gotErr, wantErr)
				}
			}
			if !reflect.DeepEqual(got, want) {
				fmt.Println("ERROR(" + path + ")\n\tgot package")
				enc.Encode(got)
				got, _ := json.MarshalIndent(got, "", "\t")

				fmt.Println("\twant package")
				enc.Encode(want)
				want, _ := json.MarshalIndent(want, "", "\t")
				b, _ := diff.Diff("", got, want)
				os.Stdout.Write(b)
				return nil
			}
			pass++
			return nil
		})
		if pass == all {
			fmt.Print("PASS", ctx.GOOS, " ", ctx.GOARCH, ctx.BuildTags, ctx.CgoEnabled)
		} else {
			fmt.Print("FAIL", ctx.GOOS, " ", ctx.GOARCH, ctx.BuildTags, ctx.CgoEnabled)
		}
		fmt.Printf(" %v/%v passing packages\n", pass, all)
	}

	rand.Seed(time.Now().UnixNano())

	for goos := range knownOS {
		for goarch := range knownArch {
			for _, cgo := range []bool{true, false} {
				ctx := getContext(goos, goarch, []string{}, cgo)
				try(ctx)
			}
		}
	}

	/*
		var actualTags []string

		for _, tag := range globalAllTags {
			if !knownOS[tag] && !knownArch[tag] && !strings.HasPrefix(tag, "go") {
				if rand.Intn(10) == 0 {
					actualTags = append(actualTags, tag)
				}
			}
		}
		var actualTagsMap = make(map[string]bool)
		for _, t := range actualTags {
			actualTagsMap[t] = true
		}

		fmt.Println("actual tags are")
		fmt.Println(actualTags)

		cgo := rand.Intn(2) == 0
	*/

}

var knownOS = map[string]bool{
	"aix":       true,
	"android":   true,
	"darwin":    true,
	"dragonfly": true,
	"freebsd":   true,
	"hurd":      true,
	"illumos":   true,
	"ios":       true,
	"js":        true,
	"linux":     true,
	"nacl":      true,
	"netbsd":    true,
	"openbsd":   true,
	"plan9":     true,
	"solaris":   true,
	"windows":   true,
	"zos":       true,
}
var knownArch = map[string]bool{
	"386":         true,
	"amd64":       true,
	"amd64p32":    true,
	"arm":         true,
	"armbe":       true,
	"arm64":       true,
	"arm64be":     true,
	"loong64":     true,
	"mips":        true,
	"mipsle":      true,
	"mips64":      true,
	"mips64le":    true,
	"mips64p32":   true,
	"mips64p32le": true,
	"ppc":         true,
	"ppc64":       true,
	"ppc64le":     true,
	"riscv":       true,
	"riscv64":     true,
	"s390":        true,
	"s390x":       true,
	"sparc":       true,
	"sparc64":     true,
	"wasm":        true,
}

func getContext(goos, goarch string, tags []string, cgo bool) build.Context {
	var c build.Context

	c.GOARCH = goarch
	c.GOOS = goos
	c.GOROOT = pathpkg.Clean(runtime.GOROOT())
	c.GOPATH = build.Default.GOPATH
	c.Compiler = runtime.Compiler

	// Each major Go release in the Go 1.x series adds a new
	// "go1.x" release tag. That is, the go1.x tag is present in
	// all releases >= Go 1.x. Code that requires Go 1.x or later
	// should say "+build go1.x", and code that should only be
	// built before Go 1.x (perhaps it is the stub to use in that
	// case) should say "+build !go1.x".
	// The last element in ReleaseTags is the current release.
	for i := 1; i <= 18; i++ {
		c.ReleaseTags = append(c.ReleaseTags, "go1."+strconv.Itoa(i))
	}

	c.CgoEnabled = cgo
	return c
}

// Remove me... this is for tryitout.
func WriteIndexRawModule(filepath string, rm *index.RawModule, moduleDir string) error {
	var packages []*index.RawPackage
	for _, m := range rm.Dirs {
		packages = append(packages, m)
	}
	b, err := index.EncodeModule(packages, moduleDir)
	if err != nil {
		return err
	}

	fmt.Println("writing file", filepath)
	return ioutil.WriteFile(filepath, b, 0644)
}
